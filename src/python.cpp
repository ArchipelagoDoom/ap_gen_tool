#include <sstream>
#include <string>
#include <vector>

#include "data.h"
#include "python.hpp"

static std::string Py_AutoGenHeader(const std::string &game_name)
{
    std::stringstream header;
    header << "# APWorld for " << game_name << std::endl;
    header << "#" << std::endl;
    header << "# This file is automatically generated by ap_gen_tool version 2.0." << std::endl;
    header << "# For more information: https://github.com/ArchipelagoDoom/ap_gen_tool" << std::endl;
    header << std::endl;
    return header.str();
}

std::string Py_IndentJoin(std::vector<std::string> lines, int indent_level)
{
    std::string indent;
    indent.resize(indent_level, ' ');

    std::stringstream s;
    for (const std::string &line : lines)
    {
        if (line.length() > 0)
            s << indent << line;
        s << std::endl;
    }

    return s.str();
}

std::string Py_QuoteString(const std::string& str)
{
    bool has_double_quote = (str.find_first_of('"') != std::string::npos);
    bool has_single_quote = (str.find_first_of('\'') != std::string::npos);
    std::string ret;

    if (!has_double_quote)
        ret = "\"" + str + "\"";
    else if (!has_single_quote)
        ret = "'" + str + "'";
    else // No choice, must escape one of the two.
    {
        for (const char c : str)
        {
            if (c == '"')
                ret += '\\';
            ret += c;
        }
    }
    return ret;
}

// ============================================================================

std::stringstream pystream;

std::stringstream& Py_CreateInitPy(game_t *game)
{
	pystream.str("");
	pystream.clear();

    pystream << Py_AutoGenHeader(game->ap_name);
    pystream << "import typing" << std::endl;
    pystream << std::endl;
    pystream << "import BaseClasses as AP" << std::endl;
    pystream << "from worlds.AutoWorld import WebWorld" << std::endl;
    pystream << "from .id1common import id1CommonWorld" << std::endl;
    pystream << "from .options import " << game->ap_class_name << "Options, " << game->ap_class_name << "OptionGroups" << std::endl;
    pystream << std::endl;
    pystream << "game_name = " << Py_QuoteString(game->ap_name) << std::endl;
    pystream << std::endl << std::endl;
    pystream << "class " << game->ap_class_name << "Location(AP.Location):" << std::endl;
    pystream << "    game: str = game_name" << std::endl;
    pystream << std::endl << std::endl;
    pystream << "class " << game->ap_class_name << "Item(AP.Item):" << std::endl;
    pystream << "    game: str = game_name" << std::endl;
    pystream << std::endl << std::endl;
    pystream << "class " << game->ap_class_name << "Web(WebWorld):" << std::endl;
    pystream << "    option_groups = " << game->ap_class_name << "OptionGroups" << std::endl;
    pystream << "    rich_text_options_doc = True" << std::endl;
    pystream << "    theme = " << Py_QuoteString("dirt") << std::endl;
    pystream << "    tutorials = [" << std::endl;
    // TODO: Tutorials?
    pystream << "    ]" << std::endl;
    pystream << std::endl << std::endl;

    // Okay boilerplate over, now time for the real meaty class
    pystream << "class " << game->ap_class_name << "World(id1CommonWorld, import_data=(__name__, " << Py_QuoteString(game->short_name + ".data.json") << ")):" << std::endl;
    pystream << "    \"\"\"" << std::endl;
    pystream << Py_IndentJoin(game->description, 4);
    pystream << "    \"\"\"" << std::endl;
    pystream << "    game = game_name" << std::endl;
    pystream << "    options_dataclass = " << game->ap_class_name << "Options" << std::endl;
    pystream << "    options: " << game->ap_class_name << "Options" << std::endl;
    pystream << "    web = " << game->ap_class_name << "Web()" << std::endl;
    pystream << "    required_client_version = (0, 6, 3)  # APDoom version 2.0.0" << std::endl;
    pystream << std::endl;
    pystream << Py_IndentJoin(WorldOptions_GetAllHooks(game, "class"), 4);

    pystream << "    extra_connection_requirements = {" << std::endl;
    pystream << "        'deathlogic': lambda self: self.options.allow_death_logic.value == 1," << std::endl;
    pystream << "        'trick_basic': lambda self: self.options.trick_difficulty.value >= 1," << std::endl;
    pystream << "        'trick_pro': lambda self: self.options.trick_difficulty.value >= 2," << std::endl;
    pystream << "        'trick_extreme': lambda self: self.options.trick_difficulty.value >= 3," << std::endl;
    pystream << Py_IndentJoin(WorldOptions_GetAllHooks(game, "extra_connection_requirements", 0), 8);
    pystream << "    }" << std::endl;
    pystream << std::endl;

    pystream << "    def create_item(self, name: str) -> " << game->ap_class_name << "Item:" << std::endl;
    pystream << "        item_id = self.item_name_to_id[name]" << std::endl;
    pystream << "        item_data = self.item_table[item_id]" << std::endl;
    pystream << "        classification = item_data.classification" << std::endl;
    pystream << std::endl;
    pystream << Py_IndentJoin(WorldOptions_GetAllHooks(game, "create_item"), 8);
    pystream << "        return " << game->ap_class_name << "Item(name, classification, item_id, self.player)" << std::endl;
    pystream << std::endl;

    pystream << "    def generate_early(self) -> None:" << std::endl;
    pystream << "        self.init_episodes()" << std::endl;
    pystream << std::endl;
    pystream << Py_IndentJoin(WorldOptions_GetAllHooks(game, "generate_early"), 8);

    pystream << "    def create_regions(self) -> None:" << std::endl;
    pystream << "        self.construct_regions()" << std::endl;
    pystream << "        self.make_regions(location_type=" << game->ap_class_name << "Location)" << std::endl;
    pystream << std::endl;
    pystream << Py_IndentJoin(WorldOptions_GetAllHooks(game, "create_regions"), 8);

    pystream << "    def set_rules(self) -> None:" << std::endl;
    pystream << "        self.make_rules()" << std::endl;
    pystream << std::endl;
    pystream << Py_IndentJoin(WorldOptions_GetAllHooks(game, "set_rules"), 8);

    pystream << "    def create_items(self) -> None:" << std::endl;
    pystream << "        self.place_level_complete_items(item_type=" << game->ap_class_name << "Item)" << std::endl;
    pystream << std::endl;
    pystream << "        itempool = self.construct_base_item_pool()" << std::endl;
    pystream << "        location_count = len(self.multiworld.get_unfilled_locations(self.player))" << std::endl;
    pystream << "        def pop_from_pool(name: str) -> str | None:" << std::endl;
    pystream << "            return itempool.pop(itempool.index(name)) if name in itempool else None" << std::endl;
    pystream << std::endl;
    pystream << "        # Give starting levels immediately" << std::endl;
    pystream << "        map_items = [pop_from_pool(map_name) for map_name in self.starting_levels]" << std::endl;
    pystream << "        [self.multiworld.push_precollected(self.create_item(n)) for n in map_items if n is not None]" << std::endl;
    pystream << std::endl;
    pystream << Py_IndentJoin(WorldOptions_GetAllHooks(game, "create_items"), 8);
    pystream << "        # Fill remainder with filler, and submit" << std::endl;
    pystream << "        self.fill_item_pool(itempool, location_count)" << std::endl;
    pystream << "        self.multiworld.itempool.extend(self.create_item(item) for item in itempool)" << std::endl;
    pystream << std::endl;

    pystream << "    def fill_slot_data(self) -> dict[str, typing.Any]:" << std::endl;
    pystream << "        slot_data = super().fill_slot_data()" << std::endl;
    pystream << std::endl;
    pystream << Py_IndentJoin(WorldOptions_GetAllHooks(game, "fill_slot_data"), 8);
    pystream << "        return slot_data" << std::endl;
    pystream << std::endl;

    return pystream;
}

std::stringstream& Py_CreateOptionsPy(game_t *game, std::vector<PyOption> &opts)
{
	pystream.str("");
	pystream.clear();

    pystream << Py_AutoGenHeader(game->ap_name);
    pystream << "from dataclasses import dataclass" << std::endl;
    pystream << "import Options as BaseOptions" << std::endl;
    pystream << "from .id1common import options as id1Options" << std::endl;
    pystream << std::endl << std::endl;

    for (const auto& option : opts)
        pystream << option.OutputClass();

    // Create dataclass
    pystream << "@dataclass" << std::endl;
    pystream << "class " << game->ap_class_name << "Options(id1Options.id1CommonOptions):" << std::endl;
    for (const auto &option : opts)
        pystream << "    " << option.OutputDataclass();
    pystream << std::endl << std::endl;    

    // Create option groups
    std::vector<std::string> group_order;
    std::map<std::string, std::vector<std::string>> option_groups;

    option_groups.try_emplace("Episodes to Play");        group_order.push_back("Episodes to Play");
    option_groups.try_emplace("Goal Options");            group_order.push_back("Goal Options");
    option_groups.try_emplace("Difficulty Options");      group_order.push_back("Difficulty Options");
    option_groups.try_emplace("Randomizer Options");      group_order.push_back("Randomizer Options");
    option_groups.try_emplace("Item & Location Options"); // Deliberately leave out of group order until the end
    for (const auto &option : opts)
    {
        if (!option.option_group.empty() && !option_groups.count(option.option_group))
        {
            option_groups.try_emplace(option.option_group);
            group_order.push_back(option.option_group);
        }
    }
    group_order.push_back("Item & Location Options");

    // Now add the options in, including common options we don't create
    option_groups["Goal Options"].push_back("id1Options.Goal");
    option_groups["Randomizer Options"].push_back("BaseOptions.ProgressionBalancing");
    option_groups["Randomizer Options"].push_back("BaseOptions.Accessibility");
    if (game->check_sanity)
	    option_groups["Randomizer Options"].push_back("id1Options.CheckSanity");
    option_groups["Randomizer Options"].push_back("id1Options.RandomMonsters");
    option_groups["Randomizer Options"].push_back("id1Options.RandomPickups");
    option_groups["Randomizer Options"].push_back("id1Options.RandomMusic");
    if (game->iwad_name != "HERETIC.WAD")
        option_groups["Randomizer Options"].push_back("id1Options.FlipLevels");
    else  // Suppress auto creation of "Game Options"
        option_groups["Randomizer Options"].push_back("BaseOptions.Removed");
    for (const auto &option : opts)
    {
        if (!option.option_group.empty())
            option_groups[option.option_group].push_back(option.GetClassName());
    }
    option_groups["Difficulty Options"].push_back("id1Options.TrickDifficulty");
    option_groups["Difficulty Options"].push_back("id1Options.AllowDeathLogic");
    option_groups["Difficulty Options"].push_back("id1Options.ResetLevelOnDeath");
    option_groups["Difficulty Options"].push_back("BaseOptions.DeathLink");

    // Now output
    pystream << game->ap_class_name << "OptionGroups = [" << std::endl;
    for (const std::string& group : group_order)
    {
        if (option_groups[group].empty())
            continue;

        pystream << "    BaseOptions.OptionGroup(" << Py_QuoteString(group) << ", [" << std::endl;
        for (const std::string &opt_class : option_groups[group])
            pystream << "        " << opt_class << "," << std::endl;

        if (group == "Item & Location Options")
            pystream << "    ], start_collapsed=True)," << std::endl;
        else
            pystream << "    ])," << std::endl;
    }
    pystream << "]" << std::endl;
    pystream << std::endl;

    return pystream;
}